# 名词记录

## 01 | 基础架构：一条SQL查询语句是如何执行的？

连接器、查询缓存、分析器、优化器、执行器

长连接

尽量减少建立连接的动作



查询缓存往往弊大于利



词法分析

语法分析



连接顺序



权限验证

慢查询日志

引擎扫描行数

## 02 | 日志系统：一条SQL更新语句是如何执行的？

redo log

酒店掌柜有一个粉板

先写日志，再写磁盘

循环写入



binlog

MySQL 自带的引擎是 MyISAM

归档

恢复



两阶段提交



## 03 | 事务隔离：为什么你改了我还看不见？

读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是
一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出
现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

undo log（回滚日志）

尽量不要使用长事务







## 04 | 深入浅出索引（上）

哈希表

顺序表

二叉树

N叉树

等值查询

范围查询

静态存储引擎

B+树

主键索引和非主键索引

自增主键

## 05 | 深入浅出索引（下）

回表

覆盖索引

最左前缀原则

在建立联合索引的时候，如何安排索引内的字段顺序。空间

索引下推：在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

## 06 | 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？

全局锁、表级锁和行锁

全局锁的典型使用场景是，做全库逻辑备份。

官方自带的逻辑备份工具是 mysqldump

single-transaction参数：导数据之前就会启动一个事务，来确保拿到一致性视图

FTWRL：Flush tables with lock(FTWRL)全局读锁

一种是表锁，一种是元数据锁（meta data lock，MDL)。

当对一个表做增删改查操作的时候，加 MDL读锁；当要对表做结构变更操作的时候，加 MDL 写锁。



## 07 | 行锁功过：怎么减少行锁对性能的影响？

两阶段锁

如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

死锁和死锁检测

超时时间

发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。

控制并发度

你可以考虑通过将一行改成逻辑上的多行来减少锁冲突。还是以影院账户为例，可以考虑放在多条记录上，比如 10 个记录，影院的账户总额等于这 10 个记录的值的总和。



## 08 | 事务到底是隔离的还是不隔离的？

MVCC(Multi-Version Concurrency Control)即多版本并发控制

在 MySQL 里，有两个“视图”的概念

view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。

InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。

InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时
候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。

而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。



快照

一个事务只需要在启动的时候声明说，“以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本”。

低水位 高水位

数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1记为高水位。

InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。

查询逻辑：取比事务编号小数据的（可重复读）快照读

更新逻辑：当前读（读提交）

更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）。

两阶段锁协议

更新数据加行锁，到这里，我们把一致性读、当前读和行锁就串起来了。



对于可重复读，查询只承认在事务启动前就已经提交完成的数据；
对于读提交，查询只承认在语句启动前就已经提交完成的数据；

## 09 | 普通索引和唯一索引，应该怎么选择？

目标页在内存中，差别不大，多了一个碰撞判断

目标页不在内存中，对于普通索引来说，则是将更新记录在 change buffer，语句执行就结束了。

写多读少，效果好，账单类、日志类的系统。

写入之后马上会做查询，change buffer 反而起到了副作用。

## 10 | MySQL为什么有时候会选错索引？

force index(a)

优化器的逻辑



使用索引 a，每次从索引 a 上拿到一个值，都要回到主键索引上查出整行数
据，这个代价优化器也要算进去的。

在判断扫描行数的时候出问题了。

索引的“区分度”

由于索引统计信息不准确导致的问题，你可以用 analyze table 来解决

对于其他优化器误判的情况，你可以在应用端用 force index 来强行指定索引，也可以通
过修改语句来引导优化器，还可以通过增加或者删除索引来绕过这个问题。

## 11 | 怎么给字符串字段加索引？

你创建索引的语句不指定前缀长度，那么索引就会包含整个字符串。

前缀索引可能会增加扫描行数

使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。

我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。

前缀索引对覆盖索引的影响

第一种方式是使用倒序存储

第二种方式是使用 hash 字段

## 12 | 为什么我的MySQL会“抖”一下？

刷脏页（flush）

第一种是“redo log 写满了，要 flush 脏页”

第二种是“内存不够用了，要先将脏页写到磁盘”

第三种场景是，生意不忙的时候，或者打烊之后。这时候柜台没事，掌柜闲着也是闲着，
不如更新账本。

第四种场景是，年底了咸亨酒店要关门几天，需要把账结清一下。这时候掌柜要把所有账
都记到账本上，这样过完年重新开张的时候，就能就着账本明确账目情况了。

## 13 | 为什么表数据删掉一半，表文件大小不变？

经过大量增删改的表，都是可能是存在空洞的。

所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。

 







## 20 | 幻读是什么，幻读有什么问题？

幻读：幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。

产生幻读的原因是，行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。

间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间



间隙锁导致的死锁

间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的







# 基础篇

## 基础架构：一条SQL查询语句是如何执行的？

执行过程中

![下载](img/下载.png)





# 实践篇